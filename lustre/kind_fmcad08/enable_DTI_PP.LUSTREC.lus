-- This file has been generated by CoCoSim2.

-- Compiler: Lustre compiler 2 (nasa_toLustre.ToLustre.m)
-- Time: 20-Mar-2019 13:42:54
node  bool_to_real(x : bool;)
returns(y : real;);
let
	y = if x then
		1.0
	    else 0.0;
tel

(*
Original block name: enable_DTI_PP/EnabledSubsystem4/Discrete_minus_TimeIntegrator
*)
node  Discrete_minus_TimeIntegrator_22_136(f_lpar_x_rpar__1 : real;
	__time_step : real;
	__nb_step : int;)
returns(F_lpar_x_rpar__1 : real;);
var Sample_1 : real;
	Sum6_1 : real;
	UnitDelay_1 : real;
let
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum6_1 = 0.0 + Sample_1 + UnitDelay_1;
	UnitDelay_1 = (0.0 -> (pre Sum6_1));
	F_lpar_x_rpar__1 = UnitDelay_1;
tel

(*
Original block name: enable_DTI_PP/EnabledSubsystem4/Discrete_minus_TimeIntegrator1
*)
node  Discrete_minus_TimeIntegrator1_60_517(f_lpar_x_rpar__1 : real;
	reset_falling_1 : bool;
	__time_step : real;
	__nb_step : int;)
returns(F_lpar_x_rpar__1 : real;);
var Constant_1 : real;
	DataTypeConversion_1 : real;
	DataTypeConversion1_1 : real;
	Init_1 : real;
	Product_1 : real;
	Product2_1 : real;
	Sample_1 : real;
	Sum1_1 : real;
	Sum2_1 : real;
	Sum3_1 : real;
	Sum4_1 : real;
	Sum5_1 : real;
	Sum6_1 : real;
	UnitDelay_1 : real;
	UnitDelay1_1 : real;
	UnitDelay2_1 : bool;
	eq0_1 : bool;
	ne1_1 : bool;
	zero_1 : real;
let
	Constant_1 = 0.0;
	DataTypeConversion_1 = bool_to_real(eq0_1);
	DataTypeConversion1_1 = bool_to_real(ne1_1);
	Init_1 = 0.0;
	Product_1 = 1.0 * Init_1 * UnitDelay1_1;
	Product2_1 = 1.0 * Sum3_1 * DataTypeConversion_1 * DataTypeConversion1_1;
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum1_1 = 0.0 + Sample_1 + Sum2_1;
	Sum2_1 = 0.0 + Sum4_1 + Product_1;
	Sum3_1 = 0.0 - UnitDelay_1 + Init_1;
	Sum4_1 = 0.0 + UnitDelay_1 + Product2_1;
	Sum5_1 = 0.0 + UnitDelay_1 + Product_1;
	Sum6_1 = 0.0 + Sum5_1 + Product2_1;
	UnitDelay_1 = (0.0 -> (pre Sum1_1));
	UnitDelay1_1 = (1.0 -> (pre Constant_1));
	UnitDelay2_1 = (false -> (pre reset_falling_1));
	eq0_1 = (bool_to_real(reset_falling_1) <= zero_1);
	ne1_1 = (bool_to_real(UnitDelay2_1) > zero_1);
	zero_1 = 0.0;
	F_lpar_x_rpar__1 = Sum6_1;
tel

(*
Original block name: enable_DTI_PP/EnabledSubsystem4/Discrete_minus_TimeIntegrator2
*)
node  Discrete_minus_TimeIntegrator2_130_530(f_lpar_x_rpar__1 : real;
	x0_1 : real;
	__time_step : real;
	__nb_step : int;)
returns(F_lpar_x_rpar__1 : real;);
var Constant_1 : real;
	Product_1 : real;
	Sample_1 : real;
	Sum1_1 : real;
	Sum2_1 : real;
	Sum6_1 : real;
	UnitDelay_1 : real;
	UnitDelay1_1 : real;
let
	Constant_1 = 0.0;
	Product_1 = 1.0 * x0_1 * UnitDelay1_1;
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum1_1 = 0.0 + Sample_1 + Sum2_1;
	Sum2_1 = 0.0 + UnitDelay_1 + Product_1;
	Sum6_1 = 0.0 + UnitDelay_1 + Product_1;
	UnitDelay_1 = (0.0 -> (pre Sum1_1));
	UnitDelay1_1 = (1.0 -> (pre Constant_1));
	F_lpar_x_rpar__1 = Sum6_1;
tel

(*
Original block name: enable_DTI_PP/EnabledSubsystem4/Discrete_minus_TimeIntegrator3
*)
node  Discrete_minus_TimeIntegrator3_159_114(f_lpar_x_rpar__1 : real;
	reset_level_1 : bool;
	x0_1 : real;
	__time_step : real;
	__nb_step : int;)
returns(F_lpar_x_rpar__1 : real;);
var Add_1 : real;
	Constant_1 : real;
	DataTypeConversion_1 : real;
	DataTypeConversion1_1 : real;
	DataTypeConversion2_1 : real;
	Product_1 : real;
	Product1_1 : real;
	Product2_1 : real;
	Sample_1 : real;
	Sum1_1 : real;
	Sum2_1 : real;
	Sum3_1 : real;
	Sum4_1 : real;
	Sum5_1 : real;
	Sum6_1 : real;
	UnitDelay_1 : real;
	UnitDelay1_1 : real;
	UnitDelay2_1 : bool;
	eq0_1 : bool;
	ne0_1 : bool;
	ne1_1 : bool;
	zero_1 : real;
let
	Add_1 = 0.0 + Product1_1 + Product2_1;
	Constant_1 = 0.0;
	DataTypeConversion_1 = bool_to_real(ne0_1);
	DataTypeConversion1_1 = bool_to_real(eq0_1);
	DataTypeConversion2_1 = bool_to_real(ne1_1);
	Product_1 = 1.0 * x0_1 * UnitDelay1_1;
	Product1_1 = 1.0 * Sum3_1 * DataTypeConversion_1;
	Product2_1 = 1.0 * Sum3_1 * DataTypeConversion1_1 * DataTypeConversion2_1;
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum1_1 = 0.0 + Sample_1 + Sum2_1;
	Sum2_1 = 0.0 + Sum4_1 + Product_1;
	Sum3_1 = 0.0 - UnitDelay_1 + x0_1;
	Sum4_1 = 0.0 + UnitDelay_1 + Add_1;
	Sum5_1 = 0.0 + UnitDelay_1 + Product_1;
	Sum6_1 = 0.0 + Sum5_1 + Add_1;
	UnitDelay_1 = (0.0 -> (pre Sum1_1));
	UnitDelay1_1 = (1.0 -> (pre Constant_1));
	UnitDelay2_1 = (false -> (pre reset_level_1));
	eq0_1 = (bool_to_real(reset_level_1) = zero_1);
	ne0_1 = (bool_to_real(reset_level_1) <> zero_1);
	ne1_1 = (bool_to_real(UnitDelay2_1) <> zero_1);
	zero_1 = 0.0;
	F_lpar_x_rpar__1 = Sum6_1;
tel

(*
Original block name: enable_DTI_PP/EnabledSubsystem4
*)
node  EnabledSubsystem4_18_599_condExecSS(In1_1 : real;
	Enable_1 : bool;
	_isEnabled : bool;
	__time_step : real;
	__nb_step : int;)
returns(Out1_1 : real;
	Out2_1 : real;
	Out3_1 : real;
	Out4_1 : real;);
var pre_Out1_1 : real;
	pre_Out2_1 : real;
	pre_Out3_1 : real;
	pre_Out4_1 : real;
	_isEnabled_clock : bool clock;
let
	pre_Out1_1 = if (__nb_step > 0) then
		(pre Out1_1)
	    else 0.0;
	pre_Out2_1 = if (__nb_step > 0) then
		(pre Out2_1)
	    else 0.0;
	pre_Out3_1 = if (__nb_step > 0) then
		(pre Out3_1)
	    else 0.0;
	pre_Out4_1 = if (__nb_step > 0) then
		(pre Out4_1)
	    else 0.0;
	_isEnabled_clock = _isEnabled;
	(Out1_1, Out2_1, Out3_1, Out4_1) = (merge _isEnabled_clock 
		(true -> (EnabledSubsystem4_18_599((In1_1 when _isEnabled_clock), (Enable_1 when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock)) every (false -> (_isEnabled_clock and (not (pre _isEnabled_clock)))))) 
		(false -> (pre_Out1_1, pre_Out2_1, pre_Out3_1, pre_Out4_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_DTI_PP/EnabledSubsystem4
*)
node  EnabledSubsystem4_18_599(In1_1 : real;
	Enable_1 : bool;
	__time_step : real;
	__nb_step : int;)
returns(Out1_1 : real;
	Out2_1 : real;
	Out3_1 : real;
	Out4_1 : real;);
var Add_1 : real;
	Discrete_minus_TimeIntegrator_1 : real;
	Discrete_minus_TimeIntegrator1_1 : real;
	Discrete_minus_TimeIntegrator2_1 : real;
	Discrete_minus_TimeIntegrator3_1 : real;
let
	Add_1 = 0.0 + bool_to_real(Enable_1) + In1_1;
	Discrete_minus_TimeIntegrator_1 = Discrete_minus_TimeIntegrator_22_136(Add_1, __time_step, __nb_step);
	Discrete_minus_TimeIntegrator1_1 = Discrete_minus_TimeIntegrator1_60_517(Add_1, Enable_1, __time_step, __nb_step);
	Discrete_minus_TimeIntegrator2_1 = Discrete_minus_TimeIntegrator2_130_530(Add_1, In1_1, __time_step, __nb_step);
	Discrete_minus_TimeIntegrator3_1 = Discrete_minus_TimeIntegrator3_159_114(Add_1, Enable_1, In1_1, __time_step, __nb_step);
	Out1_1 = Discrete_minus_TimeIntegrator_1;
	Out2_1 = Discrete_minus_TimeIntegrator1_1;
	Out3_1 = Discrete_minus_TimeIntegrator2_1;
	Out4_1 = Discrete_minus_TimeIntegrator3_1;
tel

(*
Original block name: enable_DTI_PP
*)
node  enable_DTI_PP(In1_1 : bool;
	In2_1 : real;)
returns(Out7_1 : real;
	Out8_1 : real;
	Out9_1 : real;
	Out10_1 : real;);
var ExecutionCond_of_EnabledSubsystem4_18_599 : bool;
	EnabledSubsystem4_1 : real;
	EnabledSubsystem4_2 : real;
	EnabledSubsystem4_3 : real;
	EnabledSubsystem4_4 : real;
	__time_step : real;
	__nb_step : int;
let
	ExecutionCond_of_EnabledSubsystem4_18_599 = In1_1;
	(EnabledSubsystem4_1, EnabledSubsystem4_2, EnabledSubsystem4_3, EnabledSubsystem4_4) = EnabledSubsystem4_18_599_condExecSS(In2_1, In1_1, ExecutionCond_of_EnabledSubsystem4_18_599, __time_step, __nb_step);
	Out7_1 = EnabledSubsystem4_1;
	Out8_1 = EnabledSubsystem4_2;
	Out9_1 = EnabledSubsystem4_3;
	Out10_1 = EnabledSubsystem4_4;
	__time_step = (0.0 -> ((pre __time_step) + 1.0));
	__nb_step = (0 -> ((pre __nb_step) + 1));
tel

