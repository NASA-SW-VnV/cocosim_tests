-- This file has been generated by CoCoSim2.

-- Compiler: Lustre compiler 2 (nasa_toLustre.ToLustre.m)
-- Time: 23-Oct-2020 01:56:58
node  _min_real(
	x : real; y : real;)
returns(
	z : real;);
let
	z = (if (x < y) then
		x
	    else y);
tel

(*
Original block name: hitCrossing1_PP
*)
node  hitCrossing1_PP(
	Force_1 : real; Velocity_1 : real; Velocity_stateport_1 : real; Fn2_1 : real;)
returns(
	F_fr_1 : real; Stuck_1 : bool;);
var 
	Abs_1 : real; Hit_newline_Crossing_1 : bool; Hit_newline_Crossing_1_CrossCond : bool; Min_1 : real; Product1_1 : real;
	Product2_1 : real; Sign1_1 : real; Sign2_1 : real; Switch_1 : real; mu_kinetic_1 : real;
	mu_static_1 : real; __time_step : real; __nb_step : int;
let
	Abs_1 = (if (Force_1 >= 0.0) then
		Force_1
	    else (- (Force_1)));
	Hit_newline_Crossing_1_CrossCond = ((false) -> ((((Velocity_stateport_1 > 0.0) and (not ((pre ((Velocity_stateport_1 > 0.0)))))) or ((not ((Velocity_stateport_1 > 0.0))) and (pre ((Velocity_stateport_1 > 0.0)))))));
	Hit_newline_Crossing_1 = ((Velocity_stateport_1 = 0.0) or ((not (((false) -> ((pre (Hit_newline_Crossing_1)))))) and Hit_newline_Crossing_1_CrossCond));
	Min_1 = _min_real(mu_static_1, Abs_1);
	Product1_1 = (1.0 * Min_1) * Sign1_1;
	Product2_1 = (1.0 * Sign2_1) * mu_kinetic_1;
	Sign1_1 = (if (Force_1 > 0.0) then
		1.0
	    else (if (Force_1 < 0.0) then
		(- (1.0))
	    else 0.0));
	Sign2_1 = (if (Velocity_1 > 0.0) then
		1.0
	    else (if (Velocity_1 < 0.0) then
		(- (1.0))
	    else 0.0));
	Switch_1 = (if Hit_newline_Crossing_1 then
		Product1_1
	    else Product2_1);
	mu_kinetic_1 = (Fn2_1 * 0.40);
	mu_static_1 = (Fn2_1 * 0.80);
	F_fr_1 = Switch_1;
	Stuck_1 = Hit_newline_Crossing_1;
	__time_step = ((0.0) -> (((pre (__time_step)) + 1.0)));
	__nb_step = ((0) -> (((pre (__nb_step)) + 1)));
tel

