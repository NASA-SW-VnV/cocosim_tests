-- This file has been generated by CoCoSim2.

-- Compiler: Lustre compiler 2 (nasa_toLustre.ToLustre.m)
-- Time: 20-Nov-2020 18:02:54
#open <conv>
#open <lustrec_math>
node  abs_int(
	x : int;)
returns(
	y : int;);
let
	y = (if (x >= 0) then
		x
	    else (- (x)));
tel

node  rem_int_int(
	x : int; y : int;)
returns(
	z : int;);
let
	z = (if ((y = 0) or (x = 0)) then
		0
	    else ((x mod y) - (if (((x mod y) <> 0) and (x <= 0)) then abs_int(y) else 0)));
tel

node  int_to_int32(
	x : int;)
returns(
	y : int;);
let
	y = (if (x > 2147483647) then
		(-2147483648 + rem_int_int((x - 2147483647 - 1), 4294967296))
	    else (if (x < -2147483648) then
		(2147483647 + rem_int_int((x + 2147483648 + 1), 4294967296))
	    else x));
tel

node  _max_int(
	x : int; y : int;)
returns(
	z : int;);
let
	z = (if (x > y) then
		x
	    else y);
tel

node  _max_real(
	x : real; y : real;)
returns(
	z : real;);
let
	z = (if (x > y) then
		x
	    else y);
tel

node  _min_int(
	x : int; y : int;)
returns(
	z : int;);
let
	z = (if (x < y) then
		x
	    else y);
tel


(*
Original block name: Sqrt_PP/Saturation
*)
node  Saturation_311_394(
	In_1 : real; In_2 : real; In_3 : real; __time_step : real; __nb_step : int;)
returns(
	Out_1 : real; Out_2 : real; Out_3 : real;);
var 
	lower_1 : real; lower_2 : real; lower_3 : real; lower_limit_1 : real;
let
	lower_1 = _max_real(In_1, lower_limit_1);
	lower_2 = _max_real(In_2, lower_limit_1);
	lower_3 = _max_real(In_3, lower_limit_1);
	lower_limit_1 = 0.10;
	Out_1 = lower_1;
	Out_2 = lower_2;
	Out_3 = lower_3;
tel

(*
Original block name: Sqrt_PP/Saturation1
*)
node  Saturation1_312_716(
	In_1 : real; In_2 : real; In_3 : real; __time_step : real; __nb_step : int;)
returns(
	Out_1 : real; Out_2 : real; Out_3 : real;);
var 
	lower_1 : real; lower_2 : real; lower_3 : real; lower_limit_1 : real;
let
	lower_1 = _max_real(In_1, lower_limit_1);
	lower_2 = _max_real(In_2, lower_limit_1);
	lower_3 = _max_real(In_3, lower_limit_1);
	lower_limit_1 = 0.10;
	Out_1 = lower_1;
	Out_2 = lower_2;
	Out_3 = lower_3;
tel

(*
Original block name: Sqrt_PP/Saturation2
*)
node  Saturation2_315_744(
	In_1 : real; In_2 : real; In_3 : real; __time_step : real; __nb_step : int;)
returns(
	Out_1 : real; Out_2 : real; Out_3 : real;);
var 
	lower_1 : real; lower_2 : real; lower_3 : real; lower_limit_1 : real;
let
	lower_1 = _max_real(In_1, lower_limit_1);
	lower_2 = _max_real(In_2, lower_limit_1);
	lower_3 = _max_real(In_3, lower_limit_1);
	lower_limit_1 = 0.10;
	Out_1 = lower_1;
	Out_2 = lower_2;
	Out_3 = lower_3;
tel

(*
Original block name: Sqrt_PP/Saturation3
*)
node  Saturation3_316_394(
	In_1 : int; In_2 : int; In_3 : int; __time_step : real; __nb_step : int;)
returns(
	Out_1 : int; Out_2 : int; Out_3 : int;);
var 
	lower_1 : int; lower_2 : int; lower_3 : int; lower_limit_1 : int; upper_1 : int;
	upper_2 : int; upper_3 : int; upper_limit_1 : int;
let
	assert ((-2147483648 <= In_1) and (In_1 <= 2147483647));
	assert ((-2147483648 <= In_2) and (In_2 <= 2147483647));
	assert ((-2147483648 <= In_3) and (In_3 <= 2147483647));
	lower_1 = _max_int(upper_1, lower_limit_1);
	lower_2 = _max_int(upper_2, lower_limit_1);
	lower_3 = _max_int(upper_3, lower_limit_1);
	lower_limit_1 = 0;
	upper_1 = _min_int(upper_limit_1, In_1);
	upper_2 = _min_int(upper_limit_1, In_2);
	upper_3 = _min_int(upper_limit_1, In_3);
	upper_limit_1 = 300;
	Out_1 = lower_1;
	Out_2 = lower_2;
	Out_3 = lower_3;
tel

(*
Original block name: Sqrt_PP
*)
node  Sqrt_PP(
	In1_1 : int; In1_2 : int; In1_3 : int; In2_1 : real; In2_2 : real;
	In2_3 : real; In3_1 : real; In3_2 : real; In3_3 : real; In4_1 : real;
	In4_2 : real; In4_3 : real;)
returns(
	Out1_1 : int; Out1_2 : int; Out1_3 : int; Out2_1 : real; Out2_2 : real;
	Out2_3 : real; Out3_1 : real; Out3_2 : real; Out3_3 : real; Out4_1 : real;
	Out4_2 : real; Out4_3 : real;);
var 
	Saturation_1 : real; Saturation_2 : real; Saturation_3 : real; Saturation1_1 : real; Saturation1_2 : real;
	Saturation1_3 : real; Saturation2_1 : real; Saturation2_2 : real; Saturation2_3 : real; Saturation3_1 : int;
	Saturation3_2 : int; Saturation3_3 : int; Sqrt_1 : int; Sqrt_2 : int; Sqrt_3 : int;
	Sqrt1_1 : real; Sqrt1_2 : real; Sqrt1_3 : real; Sqrt2_1 : real; Sqrt2_2 : real;
	Sqrt2_3 : real; Sqrt3_1 : real; Sqrt3_2 : real; Sqrt3_3 : real; __time_step : real;
	__nb_step : int;
let
	assert ((-2147483648 <= In1_1) and (In1_1 <= 2147483647));
	assert ((-2147483648 <= In1_2) and (In1_2 <= 2147483647));
	assert ((-2147483648 <= In1_3) and (In1_3 <= 2147483647));
	(Saturation_1, Saturation_2, Saturation_3) = Saturation_311_394(In4_1, In4_2, In4_3, __time_step, __nb_step);
	(Saturation1_1, Saturation1_2, Saturation1_3) = Saturation1_312_716(In3_1, In3_2, In3_3, __time_step, __nb_step);
	(Saturation2_1, Saturation2_2, Saturation2_3) = Saturation2_315_744(In2_1, In2_2, In2_3, __time_step, __nb_step);
	(Saturation3_1, Saturation3_2, Saturation3_3) = Saturation3_316_394(In1_1, In1_2, In1_3, __time_step, __nb_step);
	Sqrt_1 = int_to_int32(real_to_int(sqrt(int_to_real(Saturation3_1))));
	Sqrt_2 = int_to_int32(real_to_int(sqrt(int_to_real(Saturation3_2))));
	Sqrt_3 = int_to_int32(real_to_int(sqrt(int_to_real(Saturation3_3))));
	Sqrt1_1 = (if (Saturation2_1 >= 0.0) then
		sqrt(Saturation2_1)
	    else (- (sqrt((- (Saturation2_1))))));
	Sqrt1_2 = (if (Saturation2_2 >= 0.0) then
		sqrt(Saturation2_2)
	    else (- (sqrt((- (Saturation2_2))))));
	Sqrt1_3 = (if (Saturation2_3 >= 0.0) then
		sqrt(Saturation2_3)
	    else (- (sqrt((- (Saturation2_3))))));
	Sqrt2_1 = (1.0 / sqrt(Saturation1_1));
	Sqrt2_2 = (1.0 / sqrt(Saturation1_2));
	Sqrt2_3 = (1.0 / sqrt(Saturation1_3));
	Sqrt3_1 = (1.0 / sqrt(Saturation_1));
	Sqrt3_2 = (1.0 / sqrt(Saturation_2));
	Sqrt3_3 = (1.0 / sqrt(Saturation_3));
	Out1_1 = Sqrt_1;
	Out1_2 = Sqrt_2;
	Out1_3 = Sqrt_3;
	Out2_1 = Sqrt1_1;
	Out2_2 = Sqrt1_2;
	Out2_3 = Sqrt1_3;
	Out3_1 = Sqrt2_1;
	Out3_2 = Sqrt2_2;
	Out3_3 = Sqrt2_3;
	Out4_1 = Sqrt3_1;
	Out4_2 = Sqrt3_2;
	Out4_3 = Sqrt3_3;
	__time_step = ((0.0) -> (((pre (__time_step)) + 0.20)));
	__nb_step = ((0) -> (((pre (__nb_step)) + 1)));
tel

