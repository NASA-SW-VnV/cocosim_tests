-- This file has been generated by CoCoSim2.

-- Compiler: Lustre compiler 2 (nasa_toLustre.ToLustre.m)
-- Time: 23-Oct-2020 05:14:49
#open <simulink_math_fcn>
node  bool_to_real(
	x : bool;)
returns(
	y : real;);
let
	y = (if x then
		1.0
	    else 0.0);
tel

node  real_to_bool(
	x : real;)
returns(
	y : bool;);
let
	y = (x <> 0.0);
tel


(*
Original block name: SLDVBlocks1_PP/Check
Discrete Gradient/expander
*)
node  expander_299_238(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real; Out1_2 : real;);
var 
	K_1 : real; K_2 : real; Product_1 : real; Product_2 : real;
let
	K_1 = 1.0;
	K_2 = 1.0;
	Product_1 = (1.0 * u_1) * K_1;
	Product_2 = (1.0 * u_1) * K_2;
	Out1_1 = Product_1;
	Out1_2 = Product_2;
tel

(*
Original block name: SLDVBlocks1_PP/Check
Discrete Gradient
*)
node  Check_newline_DiscreteGradient_5_444(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : real;);
var 
	DataTypeConversion1_1 : real; Demux_1 : real; Demux_2 : real; IC_1 : real; S_1 : real;
	Sum_1 : real; U_1 : real; conjunction_1 : bool; conversion_1 : real; expander_1 : real;
	expander_2 : real; fall_relop_1 : bool; falling_1 : real; gradient_type_1 : real; gradient_val_1 : real;
	rise_relop_1 : bool; rising_1 : real;
let
	--%PROPERTY "Assertion_292_237" real_to_bool(DataTypeConversion1_1);
	DataTypeConversion1_1 = IC_1;
	Demux_1 = expander_1;
	Demux_2 = expander_2;
	IC_1 = (if (__nb_step = 0) then
		1.0
	    else conversion_1);
	S_1 = u_1;
	Sum_1 = 0.0 + u_1 - U_1;
	U_1 = ((0.0) -> ((pre (S_1))));
	conjunction_1 = (rise_relop_1 and fall_relop_1);
	conversion_1 = bool_to_real(conjunction_1);
	(expander_1, expander_2) = expander_299_238(gradient_type_1, __time_step, __nb_step);
	fall_relop_1 = (falling_1 < Demux_2);
	falling_1 = (Sum_1 * -1.0);
	gradient_type_1 = gradient_val_1;
	gradient_val_1 = 1.0;
	rise_relop_1 = (rising_1 < Demux_1);
	rising_1 = (Sum_1 * 1.0);
	out_1 = DataTypeConversion1_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check 
Dynamic Gap
*)
node  Check_newline_DynamicGap_6_447(
	max_1 : real; min_1 : real; u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	disjunction_1 : bool; max_relop_1 : bool; min_relop_1 : bool;
let
	--%PROPERTY "Assertion_335_237" disjunction_1;
	disjunction_1 = (max_relop_1 or min_relop_1);
	max_relop_1 = (max_1 < u_1);
	min_relop_1 = (u_1 < min_1);
	out_1 = disjunction_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check 
Dynamic Range
*)
node  Check_newline_DynamicRange_7_418(
	max_1 : real; min_1 : real; u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	conjunction_1 : bool; max_relop_1 : bool; min_relop_1 : bool;
let
	--%PROPERTY "Assertion_355_237" conjunction_1;
	conjunction_1 = (min_relop_1 and max_relop_1);
	max_relop_1 = (u_1 < max_1);
	min_relop_1 = (min_1 < u_1);
	out_1 = conjunction_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check 
Static Gap
*)
node  Check_newline_StaticGap_8_359(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	disjunction_1 : bool; max_relop_1 : bool; max_val_1 : real; min_relop_1 : bool; min_val_1 : real;
let
	--%PROPERTY "Assertion_373_237" disjunction_1;
	disjunction_1 = (max_relop_1 or min_relop_1);
	max_relop_1 = (max_val_1 <= u_1);
	max_val_1 = 100.0;
	min_relop_1 = (u_1 <= min_val_1);
	min_val_1 = 0.0;
	out_1 = disjunction_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check 
Static Range
*)
node  Check_newline_StaticRange_9_412(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	conjunction_1 : bool; max_relop_1 : bool; max_val_1 : real; min_relop_1 : bool; min_val_1 : real;
let
	--%PROPERTY "Assertion_393_237" conjunction_1;
	conjunction_1 = (min_relop_1 and max_relop_1);
	max_relop_1 = (u_1 <= max_val_1);
	max_val_1 = 100.0;
	min_relop_1 = (min_val_1 <= u_1);
	min_val_1 = 0.0;
	out_1 = conjunction_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Dynamic 
Lower Bound
*)
node  CheckDynamic_newline_LowerBound_10_407(
	min_1 : real; u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	min_relop_1 : bool;
let
	--%PROPERTY "Assertion_414_237" min_relop_1;
	min_relop_1 = (min_1 < u_1);
	out_1 = min_relop_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Dynamic 
Upper Bound
*)
node  CheckDynamic_newline_UpperBound_11_462(
	max_1 : real; u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	max_relop_1 : bool;
let
	--%PROPERTY "Assertion_426_237" max_relop_1;
	max_relop_1 = (u_1 < max_1);
	out_1 = max_relop_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Input 
Resolution1/fixed
*)
node  fixed_441_237(
	u_1 : real; resolution_1 : real; resolution_2 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	fold_1 : bool; relop_1 : bool; relop_2 : bool;
let
	fold_1 = (relop_1 or relop_2);
	relop_1 = (u_1 = resolution_1);
	relop_2 = (u_1 = resolution_2);
	out_1 = fold_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Input 
Resolution1/steps/rem
*)
node  rem_458_237(
	u_1 : real; resolution_1 : real;)
returns(
	rem_1 : real;);
let
	rem_1 = mod_real(u_1, resolution_1);
tel

(*
Original block name: SLDVBlocks1_PP/Check Input 
Resolution1/steps
*)
node  steps_454_237(
	u_1 : real; resolution_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	relop_1 : bool; rem_1 : real; tol_1 : real;
let
	relop_1 = (rem_1 <= tol_1);
	rem_1 = rem_458_237(u_1, resolution_1);
	tol_1 = 0.010;
	out_1 = relop_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Input 
Resolution1
*)
node  CheckInput_newline_Resolution1_12_463(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	dead_resolution_1 : real; dead_resolution_2 : real; dead_u_1 : real; fixed_1 : bool; resolution_1 : real;
	resolution_type_1 : real; steps_1 : bool;
let
	--%PROPERTY "Assertion_437_237" steps_1;
	dead_resolution_1 = 1.0;
	dead_resolution_2 = 1.0;
	dead_u_1 = 1.0;
	fixed_1 = fixed_441_237(dead_u_1, dead_resolution_1, dead_resolution_2, __time_step, __nb_step);
	resolution_1 = 1.0;
	resolution_type_1 = resolution_1;
	steps_1 = steps_454_237(u_1, resolution_type_1, __time_step, __nb_step);
	out_1 = steps_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Static 
Lower Bound
*)
node  CheckStatic_newline_LowerBound_13_328(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	min_relop_1 : bool; min_val_1 : real;
let
	--%PROPERTY "Assertion_489_237" min_relop_1;
	min_relop_1 = (min_val_1 <= u_1);
	min_val_1 = 0.0;
	out_1 = min_relop_1;
tel

(*
Original block name: SLDVBlocks1_PP/Check Static 
Upper Bound
*)
node  CheckStatic_newline_UpperBound_14_322(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	out_1 : bool;);
var 
	max_relop_1 : bool; max_val_1 : real;
let
	--%PROPERTY "Assertion_501_237" max_relop_1;
	max_relop_1 = (u_1 <= max_val_1);
	max_val_1 = 0.0;
	out_1 = max_relop_1;
tel

(*
Original block name: SLDVBlocks1_PP
*)
node  SLDVBlocks1_PP(
	u_1 : real; min_1 : real; max_1 : real;)
returns(
	Out1_1 : bool; Out2_1 : bool; Out3_1 : bool; Out4_1 : bool; Out5_1 : bool;
	Out6_1 : bool; Out7_1 : bool; Out8_1 : bool; Out9_1 : real; Out10_1 : bool;);
var 
	Check_newline_DiscreteGradient_1 : real; Check_newline_DynamicGap_1 : bool; Check_newline_DynamicRange_1 : bool; Check_newline_StaticGap_1 : bool; Check_newline_StaticRange_1 : bool;
	CheckDynamic_newline_LowerBound_1 : bool; CheckDynamic_newline_UpperBound_1 : bool; CheckInput_newline_Resolution1_1 : bool; CheckStatic_newline_LowerBound_1 : bool; CheckStatic_newline_UpperBound_1 : bool;
	__time_step : real; __nb_step : int;
let
	Check_newline_DiscreteGradient_1 = Check_newline_DiscreteGradient_5_444(u_1, __time_step, __nb_step);
	Check_newline_DynamicGap_1 = Check_newline_DynamicGap_6_447(max_1, min_1, u_1, __time_step, __nb_step);
	Check_newline_DynamicRange_1 = Check_newline_DynamicRange_7_418(max_1, min_1, u_1, __time_step, __nb_step);
	Check_newline_StaticGap_1 = Check_newline_StaticGap_8_359(u_1, __time_step, __nb_step);
	Check_newline_StaticRange_1 = Check_newline_StaticRange_9_412(u_1, __time_step, __nb_step);
	CheckDynamic_newline_LowerBound_1 = CheckDynamic_newline_LowerBound_10_407(min_1, u_1, __time_step, __nb_step);
	CheckDynamic_newline_UpperBound_1 = CheckDynamic_newline_UpperBound_11_462(max_1, u_1, __time_step, __nb_step);
	CheckInput_newline_Resolution1_1 = CheckInput_newline_Resolution1_12_463(u_1, __time_step, __nb_step);
	CheckStatic_newline_LowerBound_1 = CheckStatic_newline_LowerBound_13_328(u_1, __time_step, __nb_step);
	CheckStatic_newline_UpperBound_1 = CheckStatic_newline_UpperBound_14_322(u_1, __time_step, __nb_step);
	Out1_1 = CheckInput_newline_Resolution1_1;
	Out2_1 = Check_newline_DynamicGap_1;
	Out3_1 = Check_newline_DynamicRange_1;
	Out4_1 = Check_newline_StaticRange_1;
	Out5_1 = CheckDynamic_newline_LowerBound_1;
	Out6_1 = Check_newline_StaticGap_1;
	Out7_1 = CheckDynamic_newline_UpperBound_1;
	Out8_1 = CheckStatic_newline_LowerBound_1;
	Out9_1 = Check_newline_DiscreteGradient_1;
	Out10_1 = CheckStatic_newline_UpperBound_1;
	__time_step = ((0.0) -> (((pre (__time_step)) + 0.20)));
	__nb_step = ((0) -> (((pre (__nb_step)) + 1)));
tel

