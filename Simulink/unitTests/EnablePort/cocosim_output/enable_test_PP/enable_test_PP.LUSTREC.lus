-- This file has been generated by CoCoSim2.

-- Compiler: Lustre compiler 2 (nasa_toLustre.ToLustre.m)
-- Time: 20-Nov-2020 10:57:36
#open <conv>
node  bool_to_real(
	x : bool;)
returns(
	y : real;);
let
	y = (if x then
		1.0
	    else 0.0);
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem
*)
node  Enabled_newline_Subsystem_11_005_condExecSS(
	In1_1 : real; _isEnabled : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	pre_Out1_1 : real; _isEnabled_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	_isEnabled_clock = _isEnabled;
	Out1_1 = (merge _isEnabled_clock 
		(true -> Enabled_newline_Subsystem_11_005((In1_1 when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock))) 
		(false -> (pre_Out1_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem
*)
node  Enabled_newline_Subsystem_11_005(
	In1_1 : real; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
let
	Out1_1 = In1_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem1
*)
node  Enabled_newline_Subsystem1_16_166_condExecSS(
	In1_1 : real; Enable_1 : bool; _isEnabled : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	pre_Out1_1 : real; _isEnabled_clock : bool clock; _isEnabled_reset_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	_isEnabled_clock = _isEnabled;
	_isEnabled_reset_clock = ((false) -> ((_isEnabled_clock and (not ((pre (_isEnabled_clock)))))));
	Out1_1 = (merge _isEnabled_clock 
		(true -> (Enabled_newline_Subsystem1_16_166((In1_1 when _isEnabled_clock), (Enable_1 when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock)) every _isEnabled_reset_clock)) 
		(false -> (pre_Out1_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem1
*)
node  Enabled_newline_Subsystem1_16_166(
	In1_1 : real; Enable_1 : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	Add_1 : real; UnitDelay_1 : real;
let
	Add_1 = 0.0 + bool_to_real(Enable_1) + In1_1;
	UnitDelay_1 = ((0.0) -> ((pre (Add_1))));
	Out1_1 = UnitDelay_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem2
*)
node  Enabled_newline_Subsystem2_26_007_condExecSS(
	In1_1 : real; Enable_1 : int; Enable_2 : int; Enable_3 : int; _isEnabled : bool;
	__time_step : real; __nb_step : int;)
returns(
	Out1_1 : real; Out1_2 : real; Out1_3 : real;);
var 
	pre_Out1_1 : real; pre_Out1_2 : real; pre_Out1_3 : real; _isEnabled_clock : bool clock; _isEnabled_reset_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	pre_Out1_2 = (if (__nb_step > 0) then
		(pre (Out1_2))
	    else 0.0);
	pre_Out1_3 = (if (__nb_step > 0) then
		(pre (Out1_3))
	    else 0.0);
	_isEnabled_clock = _isEnabled;
	_isEnabled_reset_clock = ((false) -> ((_isEnabled_clock and (not ((pre (_isEnabled_clock)))))));
	(Out1_1, Out1_2, Out1_3) = (merge _isEnabled_clock 
		(true -> (Enabled_newline_Subsystem2_26_007((In1_1 when _isEnabled_clock), (Enable_1 when _isEnabled_clock), (Enable_2 when _isEnabled_clock), (Enable_3 when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock)) every _isEnabled_reset_clock)) 
		(false -> (pre_Out1_1, pre_Out1_2, pre_Out1_3) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem2
*)
node  Enabled_newline_Subsystem2_26_007(
	In1_1 : real; Enable_1 : int; Enable_2 : int; Enable_3 : int; __time_step : real;
	__nb_step : int;)
returns(
	Out1_1 : real; Out1_2 : real; Out1_3 : real;);
var 
	Add_1 : real; Add_2 : real; Add_3 : real; S_1 : real; S_2 : real;
	S_3 : real; U_1 : real; U_2 : real; U_3 : real;
let
	Add_1 = 0.0 + int_to_real(Enable_1) + In1_1;
	Add_2 = 0.0 + int_to_real(Enable_2) + In1_1;
	Add_3 = 0.0 + int_to_real(Enable_3) + In1_1;
	S_1 = Add_1;
	S_2 = Add_2;
	S_3 = Add_3;
	U_1 = ((0.0) -> ((pre (S_1))));
	U_2 = ((0.0) -> ((pre (S_2))));
	U_3 = ((0.0) -> ((pre (S_3))));
	Out1_1 = U_1;
	Out1_2 = U_2;
	Out1_3 = U_3;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem3
*)
node  Enabled_newline_Subsystem3_36_167_condExecSS(
	In1_1 : real; Enable_1 : real; _isEnabled : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	pre_Out1_1 : real; _isEnabled_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	_isEnabled_clock = _isEnabled;
	Out1_1 = (merge _isEnabled_clock 
		(true -> Enabled_newline_Subsystem3_36_167((In1_1 when _isEnabled_clock), (Enable_1 when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock))) 
		(false -> (pre_Out1_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem3
*)
node  Enabled_newline_Subsystem3_36_167(
	In1_1 : real; Enable_1 : real; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	Add_1 : real;
let
	Add_1 = 0.0 + Enable_1 + In1_1;
	Out1_1 = Add_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem4/Discrete_minus_Time_newline_Integrator
*)
node  Discrete_minus_Time_newline_Integrator_48_006(
	f_lpar_x_rpar__1 : real; __time_step : real; __nb_step : int;)
returns(
	F_lpar_x_rpar__1 : real;);
var 
	Sample_1 : real; Sum6_1 : real; UnitDelay_1 : real;
let
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum6_1 = 0.0 + Sample_1 + UnitDelay_1;
	UnitDelay_1 = ((0.0) -> ((pre (Sum6_1))));
	F_lpar_x_rpar__1 = UnitDelay_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem4/Discrete_minus_Time_newline_Integrator1
*)
node  Discrete_minus_Time_newline_Integrator1_49_006(
	f_lpar_x_rpar__1 : real; reset_falling_1 : real; __time_step : real; __nb_step : int;)
returns(
	F_lpar_x_rpar__1 : real;);
var 
	Constant_1 : bool; Init_1 : real; Logical_newline_Operator_1 : bool; Sample_1 : real; Sum6_1 : real;
	Switch_1 : real; Switch1_1 : real; UnitDelay_1 : real; UnitDelay1_1 : bool; UnitDelay2_1 : real;
	eq0_1 : bool; ne1_1 : bool; zero_1 : real;
let
	Constant_1 = false;
	Init_1 = 0.0;
	Logical_newline_Operator_1 = (eq0_1 and ne1_1);
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum6_1 = 0.0 + Sample_1 + Switch1_1;
	Switch_1 = (if Logical_newline_Operator_1 then
		Init_1
	    else UnitDelay_1);
	Switch1_1 = (if UnitDelay1_1 then
		Init_1
	    else Switch_1);
	UnitDelay_1 = ((0.0) -> ((pre (Sum6_1))));
	UnitDelay1_1 = ((true) -> ((pre (Constant_1))));
	UnitDelay2_1 = ((0.0) -> ((pre (reset_falling_1))));
	eq0_1 = (reset_falling_1 <= zero_1);
	ne1_1 = (UnitDelay2_1 > zero_1);
	zero_1 = 0.0;
	F_lpar_x_rpar__1 = Switch1_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem4/Discrete_minus_Time_newline_Integrator2
*)
node  Discrete_minus_Time_newline_Integrator2_50_005(
	f_lpar_x_rpar__1 : real; x0_1 : real; __time_step : real; __nb_step : int;)
returns(
	F_lpar_x_rpar__1 : real;);
var 
	Constant_1 : real; Product_1 : real; Sample_1 : real; Sum1_1 : real; Sum2_1 : real;
	Sum6_1 : real; UnitDelay_1 : real; UnitDelay1_1 : real;
let
	Constant_1 = 0.0;
	Product_1 = (1.0 * x0_1) * UnitDelay1_1;
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum1_1 = 0.0 + Sample_1 + Sum2_1;
	Sum2_1 = 0.0 + UnitDelay_1 + Product_1;
	Sum6_1 = 0.0 + UnitDelay_1 + Product_1;
	UnitDelay_1 = ((0.0) -> ((pre (Sum1_1))));
	UnitDelay1_1 = ((1.0) -> ((pre (Constant_1))));
	F_lpar_x_rpar__1 = Sum6_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem4/Discrete_minus_Time_newline_Integrator3
*)
node  Discrete_minus_Time_newline_Integrator3_51_165(
	f_lpar_x_rpar__1 : real; reset_level_1 : real; x0_1 : real; __time_step : real; __nb_step : int;)
returns(
	F_lpar_x_rpar__1 : real;);
var 
	Constant_1 : bool; LogicalOperator_1 : bool; LogicalOperator1_1 : bool; Sample_1 : real; Sum6_1 : real;
	Switch_1 : real; Switch1_1 : real; UnitDelay_1 : real; UnitDelay1_1 : bool; UnitDelay2_1 : real;
	eq0_1 : bool; ne0_1 : bool; ne1_1 : bool; zero_1 : real;
let
	Constant_1 = false;
	LogicalOperator_1 = (ne0_1 or LogicalOperator1_1);
	LogicalOperator1_1 = (eq0_1 and ne1_1);
	Sample_1 = (f_lpar_x_rpar__1 * 1.0);
	Sum6_1 = 0.0 + Sample_1 + Switch1_1;
	Switch_1 = (if LogicalOperator_1 then
		x0_1
	    else UnitDelay_1);
	Switch1_1 = (if UnitDelay1_1 then
		x0_1
	    else Switch_1);
	UnitDelay_1 = ((0.0) -> ((pre (Sum6_1))));
	UnitDelay1_1 = ((true) -> ((pre (Constant_1))));
	UnitDelay2_1 = ((0.0) -> ((pre (reset_level_1))));
	eq0_1 = (reset_level_1 = zero_1);
	ne0_1 = (reset_level_1 <> zero_1);
	ne1_1 = (UnitDelay2_1 <> zero_1);
	zero_1 = 0.0;
	F_lpar_x_rpar__1 = Switch1_1;
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem4
*)
node  Enabled_newline_Subsystem4_44_008_condExecSS(
	In1_1 : real; Enable_1 : real; _isEnabled : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real; Out2_1 : real; Out3_1 : real; Out4_1 : real;);
var 
	pre_Out1_1 : real; pre_Out2_1 : real; pre_Out3_1 : real; pre_Out4_1 : real; _isEnabled_clock : bool clock;
	_isEnabled_reset_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	pre_Out2_1 = (if (__nb_step > 0) then
		(pre (Out2_1))
	    else 0.0);
	pre_Out3_1 = (if (__nb_step > 0) then
		(pre (Out3_1))
	    else 0.0);
	pre_Out4_1 = (if (__nb_step > 0) then
		(pre (Out4_1))
	    else 0.0);
	_isEnabled_clock = _isEnabled;
	_isEnabled_reset_clock = ((false) -> ((_isEnabled_clock and (not ((pre (_isEnabled_clock)))))));
	(Out1_1, Out2_1, Out3_1, Out4_1) = (merge _isEnabled_clock 
		(true -> (Enabled_newline_Subsystem4_44_008((In1_1 when _isEnabled_clock), (Enable_1 when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock)) every _isEnabled_reset_clock)) 
		(false -> (pre_Out1_1, pre_Out2_1, pre_Out3_1, pre_Out4_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabled_newline_Subsystem4
*)
node  Enabled_newline_Subsystem4_44_008(
	In1_1 : real; Enable_1 : real; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real; Out2_1 : real; Out3_1 : real; Out4_1 : real;);
var 
	Add_1 : real; Discrete_minus_Time_newline_Integrator_1 : real; Discrete_minus_Time_newline_Integrator1_1 : real; Discrete_minus_Time_newline_Integrator2_1 : real; Discrete_minus_Time_newline_Integrator3_1 : real;
let
	Add_1 = 0.0 + Enable_1 + In1_1;
	Discrete_minus_Time_newline_Integrator_1 = Discrete_minus_Time_newline_Integrator_48_006(Add_1, __time_step, __nb_step);
	Discrete_minus_Time_newline_Integrator1_1 = Discrete_minus_Time_newline_Integrator1_49_006(Add_1, Enable_1, __time_step, __nb_step);
	Discrete_minus_Time_newline_Integrator2_1 = Discrete_minus_Time_newline_Integrator2_50_005(Add_1, In1_1, __time_step, __nb_step);
	Discrete_minus_Time_newline_Integrator3_1 = Discrete_minus_Time_newline_Integrator3_51_165(Add_1, Enable_1, In1_1, __time_step, __nb_step);
	Out1_1 = Discrete_minus_Time_newline_Integrator_1;
	Out2_1 = Discrete_minus_Time_newline_Integrator1_1;
	Out3_1 = Discrete_minus_Time_newline_Integrator2_1;
	Out4_1 = Discrete_minus_Time_newline_Integrator3_1;
tel

node  Enabledand_newline_TriggeredSubsystem_78_005_triggeredSS(
	In1_1 : real; _isEnabled : bool; _isTriggered : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	pre_Out1_1 : real; _isTriggered_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	_isTriggered_clock = _isTriggered;
	Out1_1 = (merge _isTriggered_clock 
		(true -> Enabledand_newline_TriggeredSubsystem_78_005((In1_1 when _isTriggered_clock), (__time_step when _isTriggered_clock), (__nb_step when _isTriggered_clock))) 
		(false -> (pre_Out1_1) when false(_isTriggered_clock)));
tel

(*
Original block name: enable_test_PP/Enabledand_newline_TriggeredSubsystem
*)
node  Enabledand_newline_TriggeredSubsystem_78_005_condExecSS(
	In1_1 : real; _isEnabled : bool; _isTriggered : bool; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
var 
	pre_Out1_1 : real; _isEnabled_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else 0.0);
	_isEnabled_clock = _isEnabled;
	Out1_1 = (merge _isEnabled_clock 
		(true -> Enabledand_newline_TriggeredSubsystem_78_005_triggeredSS((In1_1 when _isEnabled_clock), (_isEnabled when _isEnabled_clock), (_isTriggered when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock))) 
		(false -> (pre_Out1_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabledand_newline_TriggeredSubsystem
*)
node  Enabledand_newline_TriggeredSubsystem_78_005(
	In1_1 : real; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : real;);
let
	Out1_1 = In1_1;
tel

(*
Original block name: enable_test_PP/Enabledand_newline_TriggeredSubsystem1/Compare
To Zero
*)
node  Compare_newline_ToZero_89_005(
	u_1 : real; __time_step : real; __nb_step : int;)
returns(
	y_1 : bool;);
var 
	Compare_1 : bool; Constant_1 : real;
let
	Compare_1 = (u_1 <= Constant_1);
	Constant_1 = 0.0;
	y_1 = Compare_1;
tel

node  Enabledand_newline_TriggeredSubsystem1_84_004_triggeredSS(
	In1_1 : real; Enable_1 : bool; Trigger_1 : real; _isEnabled : bool; _isTriggered : bool;
	__time_step : real; __nb_step : int;)
returns(
	Out1_1 : bool;);
var 
	pre_Out1_1 : bool; _isTriggered_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else false);
	_isTriggered_clock = _isTriggered;
	Out1_1 = (merge _isTriggered_clock 
		(true -> Enabledand_newline_TriggeredSubsystem1_84_004((In1_1 when _isTriggered_clock), (Enable_1 when _isTriggered_clock), (Trigger_1 when _isTriggered_clock), (__time_step when _isTriggered_clock), (__nb_step when _isTriggered_clock))) 
		(false -> (pre_Out1_1) when false(_isTriggered_clock)));
tel

(*
Original block name: enable_test_PP/Enabledand_newline_TriggeredSubsystem1
*)
node  Enabledand_newline_TriggeredSubsystem1_84_004_condExecSS(
	In1_1 : real; Enable_1 : bool; Trigger_1 : real; _isEnabled : bool; _isTriggered : bool;
	__time_step : real; __nb_step : int;)
returns(
	Out1_1 : bool;);
var 
	pre_Out1_1 : bool; _isEnabled_clock : bool clock;
let
	pre_Out1_1 = (if (__nb_step > 0) then
		(pre (Out1_1))
	    else false);
	_isEnabled_clock = _isEnabled;
	Out1_1 = (merge _isEnabled_clock 
		(true -> Enabledand_newline_TriggeredSubsystem1_84_004_triggeredSS((In1_1 when _isEnabled_clock), (Enable_1 when _isEnabled_clock), (Trigger_1 when _isEnabled_clock), (_isEnabled when _isEnabled_clock), (_isTriggered when _isEnabled_clock), (__time_step when _isEnabled_clock), (__nb_step when _isEnabled_clock))) 
		(false -> (pre_Out1_1) when false(_isEnabled_clock)));
tel

(*
Original block name: enable_test_PP/Enabledand_newline_TriggeredSubsystem1
*)
node  Enabledand_newline_TriggeredSubsystem1_84_004(
	In1_1 : real; Enable_1 : bool; Trigger_1 : real; __time_step : real; __nb_step : int;)
returns(
	Out1_1 : bool;);
var 
	Add_1 : real; Compare_newline_ToZero_1 : bool; Logical_newline_Operator_1 : bool;
let
	Add_1 = 0.0 + Trigger_1 + In1_1;
	Compare_newline_ToZero_1 = Compare_newline_ToZero_89_005(Add_1, __time_step, __nb_step);
	Logical_newline_Operator_1 = (Compare_newline_ToZero_1 and Enable_1);
	Out1_1 = Logical_newline_Operator_1;
tel

(*
Original block name: enable_test_PP
*)
node  enable_test_PP(
	In1_1 : real; In2_1 : bool; In3_1 : int; In3_2 : int; In3_3 : int;
	In4_1 : real; In5_1 : real; In6_1 : real;)
returns(
	Out3_1 : real; Out1_1 : real; Out2_1 : real; Out4_1 : real; Out4_2 : real;
	Out4_3 : real; Out5_1 : real; Out6_1 : bool; Out7_1 : real; Out8_1 : real;
	Out9_1 : real; Out10_1 : real;);
var 
	ExecutionCond_of_Enabled_newline_Subsystem_11_005 : bool; Enabled_newline_Subsystem_1 : real; ExecutionCond_of_Enabled_newline_Subsystem1_16_166 : bool; Enabled_newline_Subsystem1_1 : real; ExecutionCond_of_Enabled_newline_Subsystem2_26_007 : bool;
	Enabled_newline_Subsystem2_1 : real; Enabled_newline_Subsystem2_2 : real; Enabled_newline_Subsystem2_3 : real; ExecutionCond_of_Enabled_newline_Subsystem3_36_167 : bool; Enabled_newline_Subsystem3_1 : real;
	ExecutionCond_of_Enabled_newline_Subsystem4_44_008 : bool; Enabled_newline_Subsystem4_1 : real; Enabled_newline_Subsystem4_2 : real; Enabled_newline_Subsystem4_3 : real; Enabled_newline_Subsystem4_4 : real;
	ExecutionCond_of_Enabledand_newline_TriggeredSubsystem_78_005 : bool; TriggerCond_of_Enabledand_newline_TriggeredSubsystem_78_005 : bool; EnableCond_of_Enabledand_newline_TriggeredSubsystem_78_005 : bool; Enabledand_newline_TriggeredSubsystem_1 : real; ExecutionCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 : bool;
	TriggerCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 : bool; EnableCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 : bool; Enabledand_newline_TriggeredSubsystem1_1 : bool; __time_step : real; __nb_step : int;
let
	assert ((-128 <= In3_1) and (In3_1 <= 127));
	assert ((-128 <= In3_2) and (In3_2 <= 127));
	assert ((-128 <= In3_3) and (In3_3 <= 127));
	ExecutionCond_of_Enabled_newline_Subsystem_11_005 = In2_1;
	Enabled_newline_Subsystem_1 = Enabled_newline_Subsystem_11_005_condExecSS(In1_1, ExecutionCond_of_Enabled_newline_Subsystem_11_005, __time_step, __nb_step);
	ExecutionCond_of_Enabled_newline_Subsystem1_16_166 = In2_1;
	Enabled_newline_Subsystem1_1 = Enabled_newline_Subsystem1_16_166_condExecSS(In1_1, In2_1, ExecutionCond_of_Enabled_newline_Subsystem1_16_166, __time_step, __nb_step);
	ExecutionCond_of_Enabled_newline_Subsystem2_26_007 = ((In3_1 > 0) or ((In3_2 > 0) or (In3_3 > 0)));
	(Enabled_newline_Subsystem2_1, Enabled_newline_Subsystem2_2, Enabled_newline_Subsystem2_3) = Enabled_newline_Subsystem2_26_007_condExecSS(In1_1, In3_1, In3_2, In3_3, ExecutionCond_of_Enabled_newline_Subsystem2_26_007, __time_step, __nb_step);
	ExecutionCond_of_Enabled_newline_Subsystem3_36_167 = (In4_1 > 0.0);
	Enabled_newline_Subsystem3_1 = Enabled_newline_Subsystem3_36_167_condExecSS(In1_1, In4_1, ExecutionCond_of_Enabled_newline_Subsystem3_36_167, __time_step, __nb_step);
	ExecutionCond_of_Enabled_newline_Subsystem4_44_008 = (In6_1 > 0.0);
	(Enabled_newline_Subsystem4_1, Enabled_newline_Subsystem4_2, Enabled_newline_Subsystem4_3, Enabled_newline_Subsystem4_4) = Enabled_newline_Subsystem4_44_008_condExecSS(In1_1, In6_1, ExecutionCond_of_Enabled_newline_Subsystem4_44_008, __time_step, __nb_step);
	EnableCond_of_Enabledand_newline_TriggeredSubsystem_78_005 = In2_1;
	TriggerCond_of_Enabledand_newline_TriggeredSubsystem_78_005 = ((false) -> ((In2_1 and (not ((pre (In2_1)))))));
	ExecutionCond_of_Enabledand_newline_TriggeredSubsystem_78_005 = (EnableCond_of_Enabledand_newline_TriggeredSubsystem_78_005 and TriggerCond_of_Enabledand_newline_TriggeredSubsystem_78_005);
	Enabledand_newline_TriggeredSubsystem_1 = Enabledand_newline_TriggeredSubsystem_78_005_condExecSS(In1_1, EnableCond_of_Enabledand_newline_TriggeredSubsystem_78_005, TriggerCond_of_Enabledand_newline_TriggeredSubsystem_78_005, __time_step, __nb_step);
	EnableCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 = In2_1;
	TriggerCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 = ((false) -> (((not (In2_1)) and (pre (In2_1)))));
	ExecutionCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 = (EnableCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 and TriggerCond_of_Enabledand_newline_TriggeredSubsystem1_84_004);
	Enabledand_newline_TriggeredSubsystem1_1 = Enabledand_newline_TriggeredSubsystem1_84_004_condExecSS(In5_1, In2_1, ((0.0) -> ((if TriggerCond_of_Enabledand_newline_TriggeredSubsystem1_84_004 then
		(- (1.0))
	    else 0.0))), EnableCond_of_Enabledand_newline_TriggeredSubsystem1_84_004, TriggerCond_of_Enabledand_newline_TriggeredSubsystem1_84_004, __time_step, __nb_step);
	Out3_1 = Enabled_newline_Subsystem_1;
	Out1_1 = Enabledand_newline_TriggeredSubsystem_1;
	Out2_1 = Enabled_newline_Subsystem1_1;
	Out4_1 = Enabled_newline_Subsystem2_1;
	Out4_2 = Enabled_newline_Subsystem2_2;
	Out4_3 = Enabled_newline_Subsystem2_3;
	Out5_1 = Enabled_newline_Subsystem3_1;
	Out6_1 = Enabledand_newline_TriggeredSubsystem1_1;
	Out7_1 = Enabled_newline_Subsystem4_1;
	Out8_1 = Enabled_newline_Subsystem4_2;
	Out9_1 = Enabled_newline_Subsystem4_3;
	Out10_1 = Enabled_newline_Subsystem4_4;
	__time_step = ((0.0) -> (((pre (__time_step)) + 1.0)));
	__nb_step = ((0) -> (((pre (__nb_step)) + 1)));
tel

